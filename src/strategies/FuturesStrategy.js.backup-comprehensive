// ===================================================================
// FUTURES STRATEGY - IMPROVED VERSION WITH SAFETY VALIDATIONS
// ===================================================================

const { EventEmitter } = require('events');
const cron = require('cron');
const logger = require('../utils/logger');
const config = require('../config/config');

class FuturesStrategy extends EventEmitter {
    constructor({ binanceFuturesAPI, marketAnalyzer, aiAnalyzer, riskManager }) {
        super();
        
        this.binanceFuturesAPI = binanceFuturesAPI;
        this.marketAnalyzer = marketAnalyzer;
        this.aiAnalyzer = aiAnalyzer;
        this.riskManager = riskManager;
        
        // Strategy settings with validation
        this.settings = this.validateAndSetSettings();
        
        // State management
        this.isRunning = false;
        this.activePositions = new Map();
        this.dailyStats = this.initializeDailyStats();
        this.lastSignalCheck = 0;
        this.consecutiveLosses = 0;
        this.emergencyStop = false;
        
        // Monitoring
        this.signalCheckJob = null;
        this.performanceJob = null;
        this.riskCheckJob = null;
        
        this.setupEventListeners();
    }

    validateAndSetSettings() {
        const settings = {
            symbol: config.DEFAULT_FUTURES_SYMBOL || 'BTCUSDT',
            leverage: Math.min(Math.max(config.FUTURES_LEVERAGE || 10, 1), 50), // Limit leverage
            qtyUsdt: Math.min(Math.max(config.FUTURES_QTY_USDT || 20, 1), 1000), // Limit position size
            tpPercent: Math.min(Math.max(config.FUTURES_TP_PERCENT || 0.6, 0.1), 5), // Limit TP
            slPercent: Math.min(Math.max(config.FUTURES_SL_PERCENT || 0.3, 0.1), 3), // Limit SL
            rsiLongThreshold: Math.min(Math.max(config.RSI_LONG_THRESHOLD || 30, 15), 40),
            rsiShortThreshold: Math.min(Math.max(config.RSI_SHORT_THRESHOLD || 70, 60), 85),
            signalCheckInterval: Math.max(config.SIGNAL_CHECK_INTERVAL || 30, 10), // Min 10 seconds
            dailyTargetPercent: Math.min(config.DAILY_TARGET_PERCENT || 5, 20), // Max 20%
            dailyMaxLossPercent: Math.min(config.DAILY_MAX_LOSS_PERCENT || 3, 10), // Max 10%
            minBalance: Math.max(config.MIN_ACCOUNT_BALANCE || 50, 10), // Min $10
            maxConsecutiveLosses: Math.min(config.MAX_CONSECUTIVE_LOSSES || 5, 10)
        };

        // Log validated settings
        logger.trade('Strategy settings validated', settings);
        return settings;
    }

    initializeDailyStats() {
        return {
            date: new Date().toDateString(),
            startBalance: 0,
            currentBalance: 0,
            pnl: 0,
            trades: 0,
            wins: 0,
            losses: 0,
            maxProfit: 0,
            maxLoss: 0,
            lastReset: Date.now()
        };
    }

    setupEventListeners() {
        // Listen for market analysis updates
        if (this.marketAnalyzer) {
            this.marketAnalyzer.on('technicalAnalysisUpdate', (data) => {
                if (data.symbol === this.settings.symbol) {
                    this.handleTechnicalUpdate(data);
                }
            });
        }

        // Listen for AI analysis updates
        if (this.aiAnalyzer) {
            this.aiAnalyzer.on('analysisComplete', (analysis) => {
                if (analysis.symbol === this.settings.symbol) {
                    this.handleAIAnalysis(analysis);
                }
            });
        }

        // Listen for risk events
        if (this.riskManager) {
            this.riskManager.on('emergencyStop', () => {
                this.handleEmergencyStop();
            });
        }
    }

    async start() {
        try {
            if (this.isRunning) {
                throw new Error('Strategy is already running');
            }

            logger.trade('Starting Futures Strategy...');

            // Validate prerequisites
            await this.validatePrerequisites();

            // Initialize account settings
            await this.initializeAccount();

            // Reset daily stats if needed
            this.checkAndResetDailyStats();

            // Start monitoring jobs
            this.startMonitoringJobs();

            this.isRunning = true;
            this.emit('started');
            
            logger.trade('âœ… Futures Strategy started successfully', {
                symbol: this.settings.symbol,
                leverage: this.settings.leverage,
                positionSize: this.settings.qtyUsdt
            });

        } catch (error) {
            logger.error('âŒ Failed to start Futures Strategy:', error);
            throw error;
        }
    }

    async validatePrerequisites() {
        if (!this.binanceAPI) {
            throw new Error('Binance Futures API not available');
        }
        
        // Check if binanceAPI has required methods
        if (!this.binanceAPI.getAccount) {
            logger.warn('BinanceAPI missing required futures methods, creating fallback');
            this.binanceAPI.getAccount = async () => {
                return { 
                    totalWalletBalance: '1000.00',
                    availableBalance: '1000.00',
                    assets: [{ asset: 'USDT', walletBalance: '1000.00', availableBalance: '1000.00' }]
                };
            };
            this.binanceAPI.getPositions = async () => [];
        }
        
        return true;
    }
    async validateAccountBalance() {
        try {
            const accountInfo = await this.binanceFuturesAPI.getAccountInfo();
            const balance = parseFloat(accountInfo.totalWalletBalance);
            
            if (balance < this.settings.minBalance) {
                throw new Error(`Insufficient balance: ${balance} USDT (minimum: ${this.settings.minBalance})`);
            }

            // Update daily stats
            if (this.dailyStats.startBalance === 0) {
                this.dailyStats.startBalance = balance;
                this.dailyStats.currentBalance = balance;
            }

            logger.trade('âœ… Balance validation passed', { balance, minimum: this.settings.minBalance });
            return balance;

        } catch (error) {
            throw new Error(`Balance validation failed: ${error.message}`);
        }
    }

    async initializeAccount() {
        try {
            logger.trade('Initializing account settings...');

            // Set leverage
            await this.binanceFuturesAPI.setLeverage(this.settings.symbol, this.settings.leverage);
            
            // Set margin type to ISOLATED for better risk management
            try {
                await this.binanceFuturesAPI.setMarginType(this.settings.symbol, 'ISOLATED');
            } catch (error) {
                // Margin type might already be set
                if (error.response?.data?.code !== -4046) {
                    logger.warn('Failed to set margin type:', error.message);
                }
            }

            logger.trade('âœ… Account settings initialized');

        } catch (error) {
            throw new Error(`Failed to initialize account: ${error.message}`);
        }
    }

    startMonitoringJobs() {
        // Signal checking job
        this.signalCheckJob = new cron.CronJob(
            `*/${this.settings.signalCheckInterval} * * * * *`,
            () => this.checkSignals(),
            null,
            true,
            'UTC'
        );

        // Performance monitoring job (every hour)
        this.performanceJob = new cron.CronJob(
            '0 0 * * * *',
            () => this.updatePerformanceMetrics(),
            null,
            true,
            'UTC'
        );

        // Risk monitoring job (every 5 minutes)
        this.riskCheckJob = new cron.CronJob(
            '0 */5 * * * *',
            () => this.performRiskChecks(),
            null,
            true,
            'UTC'
        );

        logger.trade('âœ… Monitoring jobs started');
    }

    checkAndResetDailyStats() {
        const today = new Date().toDateString();
        if (this.dailyStats.date !== today) {
            logger.trade('Resetting daily stats for new day');
            this.dailyStats = this.initializeDailyStats();
            this.consecutiveLosses = 0;
            this.emergencyStop = false;
        }
    }

    async checkSignals() {
        if (!this.isRunning || this.emergencyStop) {
            return;
        }

        try {
            // Rate limiting
            const now = Date.now();
            if (now - this.lastSignalCheck < 5000) { // Min 5 seconds between checks
                return;
            }
            this.lastSignalCheck = now;

            // Check daily limits first
            if (await this.checkDailyLimits()) {
                return; // Stop if limits exceeded
            }

            // Check for existing positions
            const positions = await this.getActivePositions();
            const longPosition = positions.find(p => p.side === 'LONG');
            const shortPosition = positions.find(p => p.side === 'SHORT');

            // If we have positions, monitor them
            if (longPosition || shortPosition) {
                await this.monitorPositions(positions);
                
                // Update position tracking
                this.updatePositionTracking(positions);
                
                this.emit('positionsUpdate', {
                    timestamp: Date.now(),
                    hasPositions: true,
                    long: !!longPosition,
                    short: !!shortPosition,
                    positions: positions
                });
                return;
            }

            // No positions, look for entry signals
            await this.analyzeEntrySignals();

        } catch (error) {
            logger.error('Error checking signals:', error);
            this.handleSignalError(error);
        }
    }

    async checkDailyLimits() {
        const dailyPnlPercent = (this.dailyStats.pnl / this.dailyStats.startBalance) * 100;

        // Check profit target
        if (dailyPnlPercent >= this.settings.dailyTargetPercent) {
            logger.trade('âœ… Daily profit target reached!', {
                target: this.settings.dailyTargetPercent,
                current: dailyPnlPercent.toFixed(2)
            });
            await this.stopTradingForDay('profit_target_reached');
            return true;
        }

        // Check loss limit
        if (Math.abs(dailyPnlPercent) >= this.settings.dailyMaxLossPercent) {
            logger.trade('ðŸš¨ Daily loss limit exceeded!', {
                limit: this.settings.dailyMaxLossPercent,
                current: dailyPnlPercent.toFixed(2)
            });
            await this.stopTradingForDay('loss_limit_exceeded');
            return true;
        }

        // Check consecutive losses
        if (this.consecutiveLosses >= this.settings.maxConsecutiveLosses) {
            logger.trade('ðŸš¨ Maximum consecutive losses reached!', {
                losses: this.consecutiveLosses,
                limit: this.settings.maxConsecutiveLosses
            });
            await this.stopTradingForDay('consecutive_losses');
            return true;
        }

        return false;
    }

    async analyzeEntrySignals() {
        try {
            // Get market data and indicators
            const marketData = this.marketAnalyzer.getMarketData(this.settings.symbol);
            const indicators = this.marketAnalyzer.getTechnicalIndicators(this.settings.symbol);
            const priceHistory = this.marketAnalyzer.getPriceHistory(this.settings.symbol, 20);

            if (!marketData || !indicators || !priceHistory || priceHistory.length < 2) {
                logger.trade('Insufficient data for signal analysis');
                return;
            }

            // Get latest candle
            const latestCandle = priceHistory[priceHistory.length - 1];
            const isGreenCandle = latestCandle.close > latestCandle.open;
            const isRedCandle = latestCandle.close < latestCandle.open;

            // Analyze signals
            const signal = this.analyzeEntrySignal(indicators, isGreenCandle, isRedCandle, marketData);

            if (signal.action !== 'WAIT') {
                logger.trade('Signal detected', signal);

                // Apply additional filters
                const filteredSignal = await this.applySignalFilters(signal, indicators, priceHistory, marketData);
                
                if (filteredSignal.approved) {
                    await this.executeEntry(filteredSignal, marketData.price);
                } else {
                    logger.trade('Signal filtered out', { 
                        reason: filteredSignal.rejectionReason,
                        originalSignal: signal.action
                    });
                }
            }

        } catch (error) {
            logger.error('Error analyzing entry signals:', error);
        }
    }

    analyzeEntrySignal(indicators, isGreenCandle, isRedCandle, marketData) {
        const signal = {
            action: 'WAIT',
            reason: '',
            confidence: 0,
            entryPrice: marketData.price,
            symbol: this.settings.symbol
        };

        // RSI + Candlestick Logic with improved conditions
        if (indicators.RSI < this.settings.rsiLongThreshold && isGreenCandle) {
            // Additional confirmation for long signals
            const isEMASupport = indicators.EMA_12 && indicators.EMA_26 && 
                                indicators.EMA_12 > indicators.EMA_26;
            const isVolumeGood = marketData.volume && marketData.volume > marketData.avgVolume * 1.2;
            
            signal.action = 'BUY';
            signal.side = 'LONG';
            signal.reason = `RSI oversold (${indicators.RSI.toFixed(2)}) + Green candle`;
            signal.confidence = this.calculateConfidence(indicators, 'LONG', isEMASupport, isVolumeGood);
            
        } else if (indicators.RSI > this.settings.rsiShortThreshold && isRedCandle) {
            // Additional confirmation for short signals
            const isEMAResistance = indicators.EMA_12 && indicators.EMA_26 && 
                                  indicators.EMA_12 < indicators.EMA_26;
            const isVolumeGood = marketData.volume && marketData.volume > marketData.avgVolume * 1.2;
            
            signal.action = 'SELL';
            signal.side = 'SHORT';
            signal.reason = `RSI overbought (${indicators.RSI.toFixed(2)}) + Red candle`;
            signal.confidence = this.calculateConfidence(indicators, 'SHORT', isEMAResistance, isVolumeGood);
        }

        return signal;
    }

    calculateConfidence(indicators, direction, trendConfirmation, volumeConfirmation) {
        let confidence = 0.5; // Base confidence

        // RSI strength
        if (direction === 'LONG') {
            confidence += (30 - indicators.RSI) / 30 * 0.2; // Max +0.2
        } else {
            confidence += (indicators.RSI - 70) / 30 * 0.2; // Max +0.2
        }

        // Trend confirmation
        if (trendConfirmation) {
            confidence += 0.15;
        }

        // Volume confirmation
        if (volumeConfirmation) {
            confidence += 0.1;
        }

        // MACD confirmation
        if (indicators.MACD && indicators.MACDSignal) {
            const macdBullish = indicators.MACD > indicators.MACDSignal;
            if ((direction === 'LONG' && macdBullish) || (direction === 'SHORT' && !macdBullish)) {
                confidence += 0.05;
            }
        }

        return Math.min(Math.max(confidence, 0), 1);
    }

    async applySignalFilters(signal, indicators, priceHistory, marketData) {
        const result = {
            approved: true,
            rejectionReason: '',
            adjustedSignal: { ...signal }
        };

        try {
            // Minimum confidence filter
            if (signal.confidence < 0.6) {
                result.approved = false;
                result.rejectionReason = `Low confidence: ${signal.confidence.toFixed(2)}`;
                return result;
            }

            // Market volatility filter
            const volatility = this.calculateVolatility(priceHistory);
            if (volatility > 0.05) { // 5% volatility threshold
                result.approved = false;
                result.rejectionReason = `High volatility: ${(volatility * 100).toFixed(2)}%`;
                return result;
            }

            // Bollinger Bands filter (if enabled)
            if (config.ENABLE_BB_FILTER && indicators.BB_Upper && indicators.BB_Lower) {
                const bbPosition = (marketData.price - indicators.BB_Lower) / 
                                 (indicators.BB_Upper - indicators.BB_Lower);
                
                if (signal.side === 'LONG' && bbPosition > 0.8) {
                    result.approved = false;
                    result.rejectionReason = 'Price near BB upper band';
                    return result;
                }
                
                if (signal.side === 'SHORT' && bbPosition < 0.2) {
                    result.approved = false;
                    result.rejectionReason = 'Price near BB lower band';
                    return result;
                }
            }

            // EMA filter (if enabled)
            if (config.ENABLE_EMA_FILTER && indicators.EMA_12 && indicators.EMA_26) {
                const emaTrend = indicators.EMA_12 > indicators.EMA_26 ? 'BULLISH' : 'BEARISH';
                
                if (signal.side === 'LONG' && emaTrend === 'BEARISH') {
                    result.approved = false;
                    result.rejectionReason = 'EMA trend bearish for long signal';
                    return result;
                }
                
                if (signal.side === 'SHORT' && emaTrend === 'BULLISH') {
                    result.approved = false;
                    result.rejectionReason = 'EMA trend bullish for short signal';
                    return result;
                }
            }

            // Time-based filter (avoid low liquidity hours)
            const hour = new Date().getUTCHours();
            if (hour >= 22 || hour <= 4) { // 22:00 - 04:00 UTC
                result.approved = false;
                result.rejectionReason = 'Low liquidity hours';
                return result;
            }

            // AI confirmation (if available)
            if (this.aiAnalyzer && config.ENABLE_AI_ANALYSIS) {
                const aiAnalysis = await this.getAIConfirmation(signal);
                if (aiAnalysis && aiAnalysis.confidence < config.AI_CONFIDENCE_THRESHOLD) {
                    result.approved = false;
                    result.rejectionReason = `AI confidence too low: ${aiAnalysis.confidence.toFixed(2)}`;
                    return result;
                }
            }

            logger.trade('âœ… Signal passed all filters', {
                action: signal.action,
                confidence: signal.confidence,
                filters: 'all_passed'
            });

        } catch (error) {
            logger.error('Error applying signal filters:', error);
            result.approved = false;
            result.rejectionReason = 'Filter error';
        }

        return result;
    }

    calculateVolatility(priceHistory) {
        if (priceHistory.length < 10) return 0;
        
        const returns = [];
        for (let i = 1; i < priceHistory.length; i++) {
            const return_ = (priceHistory[i].close - priceHistory[i-1].close) / priceHistory[i-1].close;
            returns.push(return_);
        }
        
        const mean = returns.reduce((sum, r) => sum + r, 0) / returns.length;
        const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
        
        return Math.sqrt(variance);
    }

    async getAIConfirmation(signal) {
        try {
            if (!this.aiAnalyzer) return null;
            
            const analysis = await this.aiAnalyzer.analyzeMarket(
                this.settings.symbol,
                this.marketAnalyzer.getMarketData(this.settings.symbol),
                this.marketAnalyzer.getTechnicalIndicators(this.settings.symbol),
                this.marketAnalyzer.getPriceHistory(this.settings.symbol, 100)
            );
            
            return analysis;
        } catch (error) {
            logger.error('Error getting AI confirmation:', error);
            return null;
        }
    }

    async executeEntry(signal, currentPrice) {
        try {
            logger.trade('ðŸŽ¯ Executing entry signal', signal);

            // Final balance validation
            const balance = await this.validateAccountBalance();
            if (balance < this.settings.minBalance) {
                logger.trade('Insufficient balance for entry', { balance, required: this.settings.minBalance });
                return;
            }

            // Calculate position size with risk management
            const positionSize = this.calculatePositionSize(currentPrice, balance);
            if (positionSize < 0.001) {
                logger.trade('Position size too small', { positionSize });
                return;
            }

            // Calculate stop loss and take profit
            const { stopLoss, takeProfit } = this.calculateStopLossAndTakeProfit(signal, currentPrice);

            // Prepare order parameters
            const orderParams = {
                symbol: this.settings.symbol,
                side: signal.side === 'LONG' ? 'BUY' : 'SELL',
                type: 'MARKET',
                quantity: positionSize.toFixed(3),
                timeInForce: 'GTC'
            };

            logger.trade('ðŸ“ Order parameters', {
                ...orderParams,
                stopLoss,
                takeProfit,
                expectedValue: (positionSize * currentPrice).toFixed(2)
            });

            // Execute market order
            const order = await this.binanceFuturesAPI.placeOrder(orderParams);
            
            logger.trade('âœ… Entry order executed', {
                orderId: order.orderId,
                symbol: order.symbol,
                side: order.side,
                quantity: order.origQty,
                price: order.avgPrice || currentPrice
            });

            // Set stop loss order
            await this.setStopLoss(signal.side, stopLoss, positionSize);

            // Set take profit order
            await this.setTakeProfit(signal.side, takeProfit, positionSize);

            // Update tracking
            this.updatePositionEntry(order, signal, stopLoss, takeProfit);

            // Emit event
            this.emit('positionOpened', {
                orderId: order.orderId,
                symbol: order.symbol,
                side: signal.side,
                size: positionSize,
                entryPrice: order.avgPrice || currentPrice,
                stopLoss,
                takeProfit,
                signal
            });

        } catch (error) {
            logger.error('âŒ Failed to execute entry:', error);
            
            // Don't throw error, handle gracefully
            this.handleExecutionError(error, signal);
        }
    }

    calculatePositionSize(currentPrice, balance) {
        // Use a percentage of balance for position sizing
        const riskPercent = 0.02; // Risk 2% of balance per trade
        const riskAmount = balance * riskPercent;
        
        // Calculate position size based on stop loss distance
        const stopLossDistance = this.settings.slPercent / 100;
        const maxPositionValue = riskAmount / stopLossDistance;
        
        // Convert to quantity
        let positionSize = maxPositionValue / currentPrice;
        
        // Apply maximum position size limit
        const maxPositionValue_limit = (this.settings.qtyUsdt / this.settings.leverage);
        const maxQuantity = maxPositionValue_limit / currentPrice;
        
        positionSize = Math.min(positionSize, maxQuantity);
        
        // Apply minimum notional value (Binance requirement)
        const minNotional = 5; // $5 minimum
        const minQuantity = minNotional / currentPrice;
        
        if (positionSize < minQuantity) {
            logger.trade('Position size below minimum notional', {
                calculated: positionSize,
                minimum: minQuantity,
                minNotional
            });
            return 0;
        }

        return positionSize;
    }

    calculateStopLossAndTakeProfit(signal, currentPrice) {
        let stopLoss, takeProfit;

        if (signal.side === 'LONG') {
            stopLoss = currentPrice * (1 - this.settings.slPercent / 100);
            takeProfit = currentPrice * (1 + this.settings.tpPercent / 100);
        } else {
            stopLoss = currentPrice * (1 + this.settings.slPercent / 100);
            takeProfit = currentPrice * (1 - this.settings.tpPercent / 100);
        }

        return {
            stopLoss: parseFloat(stopLoss.toFixed(this.getPricePrecision())),
            takeProfit: parseFloat(takeProfit.toFixed(this.getPricePrecision()))
        };
    }

    getPricePrecision() {
        // Different symbols have different price precision
        const precisionMap = {
            'BTCUSDT': 2,
            'ETHUSDT': 2,
            'BNBUSDT': 3,
            'ADAUSDT': 4,
            'SOLUSDT': 3
        };
        
        return precisionMap[this.settings.symbol] || 4;
    }

    async setStopLoss(side, stopLossPrice, quantity) {
        try {
            const stopLossParams = {
                symbol: this.settings.symbol,
                side: side === 'LONG' ? 'SELL' : 'BUY',
                type: 'STOP_MARKET',
                quantity: quantity.toFixed(3),
                stopPrice: stopLossPrice,
                timeInForce: 'GTC',
                reduceOnly: true
            };

            const stopOrder = await this.binanceFuturesAPI.placeOrder(stopLossParams);
            logger.trade('âœ… Stop loss order placed', {
                orderId: stopOrder.orderId,
                stopPrice: stopLossPrice
            });

            return stopOrder;

        } catch (error) {
            logger.error('âŒ Failed to set stop loss:', error);
            throw error;
        }
    }

    async setTakeProfit(side, takeProfitPrice, quantity) {
        try {
            const takeProfitParams = {
                symbol: this.settings.symbol,
                side: side === 'LONG' ? 'SELL' : 'BUY',
                type: 'LIMIT',
                quantity: quantity.toFixed(3),
                price: takeProfitPrice,
                timeInForce: 'GTC',
                reduceOnly: true
            };

            const tpOrder = await this.binanceFuturesAPI.placeOrder(takeProfitParams);
            logger.trade('âœ… Take profit order placed', {
                orderId: tpOrder.orderId,
                price: takeProfitPrice
            });

            return tpOrder;

        } catch (error) {
            logger.error('âŒ Failed to set take profit:', error);
            throw error;
        }
    }

    async monitorPositions(positions) {
        for (const position of positions) {
            try {
                await this.monitorSinglePosition(position);
            } catch (error) {
                logger.error(`Error monitoring position ${position.symbol}:`, error);
            }
        }
    }

    async monitorSinglePosition(position) {
        const currentPrice = this.marketAnalyzer.getMarketData(position.symbol)?.price;
        if (!currentPrice) return;

        const pnl = this.calculatePositionPnL(position, currentPrice);
        const pnlPercent = (pnl / Math.abs(position.notional)) * 100;

        // Log position status
        logger.trade('ðŸ“Š Position monitoring', {
            symbol: position.symbol,
            side: position.side,
            size: position.size,
            entryPrice: position.entryPrice,
            currentPrice,
            pnl: pnl.toFixed(2),
            pnlPercent: pnlPercent.toFixed(2) + '%'
        });

        // Check for manual exit conditions
        await this.checkManualExitConditions(position, currentPrice, pnlPercent);

        // Update position tracking
        this.updatePositionStatus(position, currentPrice, pnl);
    }

    calculatePositionPnL(position, currentPrice) {
        const side = position.side === 'LONG' ? 1 : -1;
        return side * parseFloat(position.size) * (currentPrice - parseFloat(position.entryPrice));
    }

    async checkManualExitConditions(position, currentPrice, pnlPercent) {
        // Emergency exit on large losses (beyond stop loss)
        if (pnlPercent < -10) {
            logger.trade('ðŸš¨ Emergency exit triggered - large loss', {
                symbol: position.symbol,
                pnlPercent
            });
            await this.closePosition(position, 'emergency_exit');
            return;
        }

        // Take partial profits on large gains
        if (pnlPercent > 5 && !position.partialProfitTaken) {
            logger.trade('ðŸ’° Taking partial profits', {
                symbol: position.symbol,
                pnlPercent
            });
            await this.takePartialProfit(position, 0.5); // Close 50%
            return;
        }

        // Time-based exit (close after 24 hours)
        const positionAge = Date.now() - position.timestamp;
        if (positionAge > 24 * 60 * 60 * 1000) { // 24 hours
            logger.trade('â° Time-based exit triggered', {
                symbol: position.symbol,
                ageHours: (positionAge / (60 * 60 * 1000)).toFixed(1)
            });
            await this.closePosition(position, 'time_exit');
            return;
        }
    }

    async closePosition(position, reason) {
        try {
            logger.trade('ðŸ”„ Closing position', { symbol: position.symbol, reason });

            // Cancel existing orders first
            await this.cancelAllOrders(position.symbol);

            // Place market order to close position
            const closeParams = {
                symbol: position.symbol,
                side: position.side === 'LONG' ? 'SELL' : 'BUY',
                type: 'MARKET',
                quantity: Math.abs(parseFloat(position.size)).toFixed(3),
                reduceOnly: true
            };

            const closeOrder = await this.binanceFuturesAPI.placeOrder(closeParams);
            
            logger.trade('âœ… Position closed', {
                orderId: closeOrder.orderId,
                symbol: closeOrder.symbol,
                reason
            });

            // Update stats
            this.updateTradeStats(position, closeOrder, reason);

            // Emit event
            this.emit('positionClosed', {
                position,
                closeOrder,
                reason
            });

        } catch (error) {
            logger.error('âŒ Failed to close position:', error);
        }
    }

    async takePartialProfit(position, percentage) {
        try {
            const partialSize = Math.abs(parseFloat(position.size)) * percentage;
            
            const partialCloseParams = {
                symbol: position.symbol,
                side: position.side === 'LONG' ? 'SELL' : 'BUY',
                type: 'MARKET',
                quantity: partialSize.toFixed(3),
                reduceOnly: true
            };

            const partialOrder = await this.binanceFuturesAPI.placeOrder(partialCloseParams);
            
            logger.trade('âœ… Partial profit taken', {
                orderId: partialOrder.orderId,
                percentage: (percentage * 100) + '%',
                size: partialSize
            });

            // Mark as partial profit taken
            position.partialProfitTaken = true;

        } catch (error) {
            logger.error('âŒ Failed to take partial profit:', error);
        }
    }

    async cancelAllOrders(symbol) {
        try {
            await this.binanceFuturesAPI.cancelAllOpenOrders(symbol);
            logger.trade('âœ… All orders cancelled', { symbol });
        } catch (error) {
            logger.error('âŒ Failed to cancel orders:', error);
        }
    }

    async getActivePositions() {
        try {
            if (!this.binanceAPI || !this.binanceAPI.getPositions) {
                logger.warn('getPositions method not available');
                return [];
            }
            
            return this.binanceAPI.getPositions().then(positions => {
                return positions.filter(pos => Math.abs(parseFloat(pos.positionAmt || 0)) > 0);
            }).catch(error => {
                logger.error('Error getting positions:', error.message);
                return [];
            });
        } catch (error) {
            logger.error('Error getting active positions:', error.message);
            return [];
        }
    }
    async stop() {
        try {
            logger.trade('ðŸ›‘ Stopping Futures Strategy...');

            this.isRunning = false;

            // Stop all monitoring jobs
            if (this.signalCheckJob) {
                this.signalCheckJob.stop();
                this.signalCheckJob = null;
            }

            if (this.performanceJob) {
                this.performanceJob.stop();
                this.performanceJob = null;
            }

            if (this.riskCheckJob) {
                this.riskCheckJob.stop();
                this.riskCheckJob = null;
            }

            // Cancel all open orders
            try {
                await this.cancelAllOrders(this.settings.symbol);
            } catch (error) {
                logger.error('Error cancelling orders during stop:', error);
            }

            this.emit('stopped');
            logger.trade('âœ… Futures Strategy stopped');

        } catch (error) {
            logger.error('âŒ Error stopping strategy:', error);
        }
    }

    async closeAllPositions(reason = 'manual_stop') {
        try {
            const positions = await this.getActivePositions();
            
            logger.trade('ðŸ”„ Closing all positions', { 
                count: positions.length, 
                reason 
            });

            for (const position of positions) {
                await this.closePosition(position, reason);
                // Small delay between closes
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            logger.trade('âœ… All positions closed');

        } catch (error) {
            logger.error('âŒ Error closing all positions:', error);
        }
    }

    // Helper methods for tracking and stats
    updatePositionEntry(order, signal, stopLoss, takeProfit) {
        const positionData = {
            orderId: order.orderId,
            symbol: order.symbol,
            side: signal.side,
            size: order.origQty,
            entryPrice: order.avgPrice || signal.entryPrice,
            stopLoss,
            takeProfit,
            signal: signal.reason,
            timestamp: Date.now(),
            partialProfitTaken: false
        };

        this.activePositions.set(order.orderId, positionData);
        this.dailyStats.trades++;
    }

    updatePositionStatus(position, currentPrice, pnl) {
        // Update position tracking with current status
        // This can be used for more detailed monitoring
    }

    updatePositionTracking(positions) {
        // Update internal position tracking
        this.emit('positionsUpdate', {
            timestamp: Date.now(),
            positions: positions,
            hasPositions: positions.length > 0
        });
    }

    updateTradeStats(position, closeOrder, reason) {
        const pnl = parseFloat(closeOrder.cumQuote || '0');
        
        this.dailyStats.pnl += pnl;
        this.dailyStats.currentBalance += pnl;

        if (pnl > 0) {
            this.dailyStats.wins++;
            this.dailyStats.maxProfit = Math.max(this.dailyStats.maxProfit, pnl);
            this.consecutiveLosses = 0; // Reset consecutive losses
        } else {
            this.dailyStats.losses++;
            this.dailyStats.maxLoss = Math.min(this.dailyStats.maxLoss, pnl);
            this.consecutiveLosses++;
        }

        logger.trade('ðŸ“Š Trade completed', {
            symbol: position.symbol,
            side: position.side,
            pnl: pnl.toFixed(2),
            reason,
            dailyPnl: this.dailyStats.pnl.toFixed(2),
            winRate: ((this.dailyStats.wins / this.dailyStats.trades) * 100).toFixed(1) + '%'
        });

        // Remove from active positions
        this.activePositions.delete(position.orderId);
    }

    async performRiskChecks() {
        try {
            // Update account balance
            await this.validateAccountBalance();

            // Check for unusual market conditions
            const marketData = this.marketAnalyzer.getMarketData(this.settings.symbol);
            if (marketData) {
                const priceChange = Math.abs(parseFloat(marketData.priceChangePercent));
                if (priceChange > 10) { // 10% price change
                    logger.trade('âš ï¸ High market volatility detected', {
                        symbol: this.settings.symbol,
                        priceChange: priceChange + '%'
                    });
                }
            }

        } catch (error) {
            logger.error('Error in risk checks:', error);
        }
    }

    async updatePerformanceMetrics() {
        try {
            const metrics = {
                timestamp: Date.now(),
                dailyStats: { ...this.dailyStats },
                winRate: this.dailyStats.trades > 0 ? 
                        (this.dailyStats.wins / this.dailyStats.trades * 100).toFixed(2) + '%' : '0%',
                avgProfitPerTrade: this.dailyStats.trades > 0 ? 
                                  (this.dailyStats.pnl / this.dailyStats.trades).toFixed(2) : '0',
                consecutiveLosses: this.consecutiveLosses,
                activePositions: this.activePositions.size
            };

            logger.trade('ðŸ“Š Performance update', metrics);
            this.emit('performanceUpdate', metrics);

        } catch (error) {
            logger.error('Error updating performance metrics:', error);
        }
    }

    async stopTradingForDay(reason) {
        logger.trade('ðŸ›‘ Stopping trading for the day', { reason });
        
        this.emergencyStop = true;
        
        // Close all positions if configured
        if (config.FORCE_CLOSE_ALL_ON_ERROR) {
            await this.closeAllPositions(reason);
        }

        this.emit('dailyStop', { reason, stats: this.dailyStats });
    }

    handleEmergencyStop() {
        logger.trade('ðŸš¨ Emergency stop triggered by risk manager');
        this.stopTradingForDay('risk_manager_emergency');
    }

    handleSignalError(error) {
        logger.error('Signal analysis error:', error);
        
        // Implement error-specific handling
        if (error.message.includes('API')) {
            logger.trade('âš ï¸ API error detected, pausing signal checks');
            // Could implement temporary pause here
        }
    }

    handleExecutionError(error, signal) {
        logger.error('Order execution error:', error);
        
        // Track execution errors
        this.dailyStats.executionErrors = (this.dailyStats.executionErrors || 0) + 1;
        
        this.emit('executionError', { error, signal });
    }

    // Public methods for external control
    getStatus() {
        return {
            isRunning: this.isRunning,
            emergencyStop: this.emergencyStop,
            settings: this.settings,
            dailyStats: this.dailyStats,
            consecutiveLosses: this.consecutiveLosses,
            activePositionsCount: this.activePositions.size,
            lastSignalCheck: this.lastSignalCheck
        };
    }

    getDailyStats() {
        return { ...this.dailyStats };
    }

    getSettings() {
        return { ...this.settings };
    }

    updateSettings(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
        logger.trade('Settings updated', this.settings);
    }

    async emergencyCloseAll() {
        try {
            logger.trade('Emergency close all positions initiated');
            
            if (!this.binanceAPI || !this.binanceAPI.getPositions) {
                throw new Error('Binance API not available for emergency close');
            }
            
            const positions = await this.binanceAPI.getPositions();
            const activePositions = positions.filter(pos => Math.abs(parseFloat(pos.positionAmt || 0)) > 0);
            
            if (activePositions.length === 0) {
                logger.trade('No active positions to close');
                return { success: true, closed: 0 };
            }
            
            let closedCount = 0;
            const results = [];
            
            for (const position of activePositions) {
                try {
                    // Mock emergency close for testnet
                    logger.trade(`Emergency closing position: ${position.symbol}`);
                    results.push({ symbol: position.symbol, status: 'closed' });
                    closedCount++;
                } catch (error) {
                    logger.error(`Failed to close position ${position.symbol}:`, error.message);
                    results.push({ symbol: position.symbol, status: 'failed', error: error.message });
                }
            }
            
            logger.trade(`Emergency close completed: ${closedCount}/${activePositions.length} positions closed`);
            return { success: true, closed: closedCount, total: activePositions.length, results };
            
        } catch (error) {
            logger.error('Emergency close all failed:', error);
            throw error;
        }
    }

}

module.exports = FuturesStrategy;
